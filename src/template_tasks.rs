use crate::filetools::template_tasks_path;
use chrono::{Datelike, NaiveDate, Weekday};
use iced::{
    Element,
    widget::{
        self, Space, Text, button, checkbox, column, row,
        text_editor::{Action, Content},
    },
};
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fs};
use strum::Display;

#[derive(Debug, Clone)]
/// types of messages generated by Standard template tasks
pub enum StandardMessage {
    CheckedBox(bool),
    TextEdit(Action),
}

#[derive(Debug, Default)]
/// the standard task with a text box and a single checkbox
pub struct StandardData {
    text_content: Content,
    completed: bool,
}

#[derive(Debug, Serialize, Deserialize)]
/// StandardData task data as stored on disk
pub struct StandardDataDisk {
    text: String,
    completed: bool,
}

impl From<&StandardDataDisk> for StandardData {
    fn from(value: &StandardDataDisk) -> Self {
        StandardData {
            text_content: Content::with_text(&value.text),
            completed: value.completed,
        }
    }
}

impl From<&StandardData> for StandardDataDisk {
    fn from(value: &StandardData) -> Self {
        let mut text = value.text_content.text();
        text.pop();

        StandardDataDisk {
            text,
            completed: value.completed,
        }
    }
}

impl StandardData {
    /// creates an empty StandardData
    pub fn new() -> Self {
        StandardData::default()
    }

    /// set if the task was completed or not
    pub fn set_completion(&mut self, completed: bool) {
        self.completed = completed;
    }
}

#[derive(Debug, Clone)]
/// messages generated by MultiBinary tasks
pub enum MultiBinaryMessage {
    CheckedNth((usize, bool)),
    TextEdit(Action),
}

#[derive(Debug, Default)]
/// a task that can have any number of binary subtasks. the names of the subtasks are stored in the common data section
pub struct MultiBinaryData {
    text_content: Content,
    subtask_completion: Vec<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
/// data that is common to all MultiBinary tasks
pub struct MultiBinaryCommonData {
    subtask_names: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MultiBinaryDataDisk {
    text: String,
    subtask_completion: Vec<bool>,
}

impl From<&MultiBinaryDataDisk> for MultiBinaryData {
    fn from(value: &MultiBinaryDataDisk) -> Self {
        MultiBinaryData {
            text_content: Content::with_text(&value.text),
            subtask_completion: value.subtask_completion.clone(),
        }
    }
}

impl From<&MultiBinaryData> for MultiBinaryDataDisk {
    fn from(value: &MultiBinaryData) -> Self {
        let mut text = value.text_content.text();
        text.pop();

        Self {
            text,
            subtask_completion: value.subtask_completion.clone(),
        }
    }
}

impl MultiBinaryData {
    /// creates an empty MultiBinaryData with the given number of subtasks. the number of subtasks must match the
    /// number in the common data section
    pub fn new(subtask_count: usize) -> Self {
        Self {
            text_content: Content::new(),
            subtask_completion: vec![false; subtask_count],
        }
    }

    pub fn set_completion(&mut self, completion_index: usize, completed: bool) {
        self.subtask_completion[completion_index] = completed;
    }
}

impl MultiBinaryCommonData {
    /// creates the subtask names of the MultiBinary task
    pub fn new(subtask_names: Vec<String>) -> Self {
        Self { subtask_names }
    }
}

#[derive(Debug)]
/// types of different data formats used by the template tasks
pub enum TaskDataFormat {
    Standard(StandardData),
    MultiBinary(MultiBinaryData),
}

impl TaskDataFormat {
    /// converts the data format into the corresponding TaskType
    pub fn task_type(&self) -> TaskType {
        match self {
            TaskDataFormat::Standard(_) => TaskType::Standard,
            TaskDataFormat::MultiBinary(_) => TaskType::MultiBinary,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
/// the types of shared data formats used by the template tasks
pub enum TaskCommonDataFormat {
    Standard,
    MultiBinary(MultiBinaryCommonData),
}

#[derive(Debug, Serialize, Deserialize)]
/// types of data formats stored on disk by the template tasks
pub enum TaskDataDiskFormat {
    Standard(StandardDataDisk),
    MultiBinary(MultiBinaryDataDisk),
}

impl From<&TaskDataDiskFormat> for TaskDataFormat {
    fn from(value: &TaskDataDiskFormat) -> Self {
        match value {
            TaskDataDiskFormat::Standard(standard_data_disk) => {
                TaskDataFormat::Standard(standard_data_disk.into())
            }
            TaskDataDiskFormat::MultiBinary(multi_binary_data_disk) => {
                TaskDataFormat::MultiBinary(multi_binary_data_disk.into())
            }
        }
    }
}

impl From<&TaskDataFormat> for TaskDataDiskFormat {
    fn from(value: &TaskDataFormat) -> Self {
        match value {
            TaskDataFormat::Standard(standard_data) => {
                TaskDataDiskFormat::Standard(standard_data.into())
            }
            TaskDataFormat::MultiBinary(multi_binary_data) => {
                TaskDataDiskFormat::MultiBinary(multi_binary_data.into())
            }
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Display, Serialize, Deserialize)]
/// these are the types of templates that can be created
pub enum TaskType {
    Standard,
    MultiBinary,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
/// the Frequency represents the schedule of how often the templates trigger
pub enum Frequency {
    Daily,
    Weekly([bool; 7]),
    Monthly([bool; 31]),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FrequencyType {
    Daily,
    Weekly,
    Monthly,
}

impl Frequency {
    /// returns if the frequency would be scheduled to be active on the given date
    pub fn is_active(&self, active_date: NaiveDate) -> bool {
        match self {
            Frequency::Daily => {
                return true;
            }
            Frequency::Weekly(daymap) => {
                let current_day = active_date.weekday();

                if Self::weekly_is(current_day, daymap, Weekday::Sun) {
                    return true;
                }
            }
            Frequency::Monthly(daymap) => {
                let day_of_month = active_date.day0() as usize;

                if daymap[day_of_month] {
                    return true;
                }
            }
        }

        false
    }

    /// checks if the given weekday would be active based on the daymap and the weekday defined as daymap[0]
    fn weekly_is(current_day: Weekday, daymap: &[bool; 7], week_start_day: Weekday) -> bool {
        let mut day_index = 0;

        let mut iterative_day = week_start_day;

        while iterative_day != current_day {
            iterative_day = iterative_day.succ();
            day_index += 1;
        }

        daymap[day_index]
    }
}

#[derive(Debug, Clone)]
/// types of messages that all TemplateTasks are able to create
pub enum CommonMessage {
    ExpandToggled,
}

#[derive(Debug, Clone)]
/// all types of messages a TemplateTask is able to create. excluding the common messages, the generated message type
/// must match the template type
pub enum TemplateMessage {
    Common(CommonMessage),
    Standard(StandardMessage),
    MultiBinary(MultiBinaryMessage),
}

#[derive(Debug, Clone)]
/// a TemplateMessage wrapper used to pinpoint which TemplateTask and which entry generated the TemplateMessage. since
/// we've dropped the generics from the Element builders, always returning our own custom messages, the message is
/// effectively being generated at the bottom of the update() hierarchy. as such, the information of what and where it
/// is located in the TemplateTask hierarchy must be stored, since the generic information that would normally contain
/// this if we were using iced Elements properly with generics is not present. this allows the message to be able to
/// locate where it originated and find its destination when the message gets passed through the update()
pub struct TemplateTaskMessage {
    date: NaiveDate,
    name: String,
    task_type: TaskType,
    message: TemplateMessage,
}

impl TemplateTaskMessage {
    /// create a TemplateTaskMessage from the Template task on the given date with the given message, containing all
    /// the information required to locate the TemplateTask and entry
    pub fn snapshot(
        origin_task: &TemplateTask,
        entry_date: NaiveDate,
        message: TemplateMessage,
    ) -> Self {
        Self {
            date: entry_date,
            name: origin_task.name.clone(),
            task_type: origin_task.task_type,
            message,
        }
    }
}

#[derive(Debug)]
/// the actual template that stores the repeated tasks. for the TemplateTask to operate properly, its TaskType MUST
/// align with its TaskDataFormat
pub struct TemplateTask {
    name: String,
    task_type: TaskType,
    creation_date: NaiveDate,
    ended_date: Option<NaiveDate>,
    frequency: Frequency,
    common_entry_format: TaskCommonDataFormat,
    entries: HashMap<NaiveDate, TaskDataFormat>,
    expanded: bool,
}

#[derive(Debug, Serialize, Deserialize)]
/// disk format of the TemplateTask
pub struct TemplateTaskDisk {
    name: String,
    task_type: TaskType,
    creation_date: NaiveDate,
    ended_date: Option<NaiveDate>,
    frequency: Frequency,
    common_entry_format: TaskCommonDataFormat,
    entries: Vec<(NaiveDate, TaskDataDiskFormat)>,
    expanded: bool,
}

impl From<&TemplateTaskDisk> for TemplateTask {
    fn from(value: &TemplateTaskDisk) -> Self {
        let mut entries = HashMap::new();

        for (date, disk_data) in &value.entries {
            entries.insert(*date, disk_data.into());
        }

        TemplateTask {
            name: value.name.clone(),
            task_type: value.task_type,
            creation_date: value.creation_date,
            ended_date: value.ended_date,
            frequency: value.frequency.clone(),
            common_entry_format: value.common_entry_format.clone(),
            entries,
            expanded: value.expanded,
        }
    }
}

impl From<&TemplateTask> for TemplateTaskDisk {
    fn from(value: &TemplateTask) -> Self {
        let mut entries = vec![];

        for (date, data) in &value.entries {
            entries.push((*date, data.into()));
        }

        entries.sort_by_key(|(date, _disk)| *date);

        TemplateTaskDisk {
            name: value.name.clone(),
            task_type: value.task_type,
            creation_date: value.creation_date,
            ended_date: value.ended_date,
            frequency: value.frequency.clone(),
            common_entry_format: value.common_entry_format.clone(),
            entries,
            expanded: value.expanded,
        }
    }
}

impl TemplateTask {
    /// creates a new template task and automatically creates an entry if the creation date would have an entry
    pub fn new(
        name: String,
        task_type: TaskType,
        common_entry_format: TaskCommonDataFormat,
        creation_date: NaiveDate,
        frequency: Frequency,
    ) -> Self {
        let mut new_task = Self {
            name,
            task_type,
            creation_date,
            ended_date: None,
            frequency,
            common_entry_format,
            entries: HashMap::new(),
            expanded: false,
        };

        if new_task.is_active(creation_date) {
            new_task.add_empty_entry(task_type, creation_date);
        }

        new_task
    }

    /// returns the type of the template
    pub fn get_type(&self) -> TaskType {
        self.task_type
    }

    /// returns the name of the template
    pub fn get_name(&self) -> String {
        self.name.clone()
    }

    /// returns if the template is scheduled for an entry on the given date
    pub fn is_active(&self, active_date: NaiveDate) -> bool {
        if active_date < self.creation_date {
            return false;
        }

        if let Some(ended_date) = self.ended_date
            && active_date > ended_date
        {
            return false;
        }

        self.frequency.is_active(active_date)
    }

    /// adds a default entry to the entries list. does not perform validation against the frequency of the template
    pub fn add_empty_entry(&mut self, entry_type: TaskType, entry_date: NaiveDate) {
        let empty_entry = match entry_type {
            TaskType::Standard => TaskDataFormat::Standard(StandardData::new()),
            TaskType::MultiBinary => {
                let subtask_count = match &self.common_entry_format {
                    TaskCommonDataFormat::MultiBinary(multi_binary_common_data) => {
                        multi_binary_common_data.subtask_names.len()
                    }
                    _ => unreachable!("malformed TaskCommonDataFormat"),
                };

                TaskDataFormat::MultiBinary(MultiBinaryData::new(subtask_count))
            }
        };

        self.entries.insert(entry_date, empty_entry);
    }

    /// returns the entry for template on the given date, returning None if entry is nonexistent
    pub fn get_entry(&self, entry_date: NaiveDate) -> Option<&TaskDataFormat> {
        self.entries.get(&entry_date)
    }

    /// returns mutable access to the entry on the given date, returning None if entry is nonexistent
    pub fn get_entry_mut(&mut self, entry_date: NaiveDate) -> Option<&mut TaskDataFormat> {
        self.entries.get_mut(&entry_date)
    }

    /// sets if the entry is expanded (true) or collapsed (false) when rendered
    pub fn set_expansion(&mut self, expanded: bool) {
        self.expanded = expanded;
    }

    /// builds the template to an element for the given date. if the entry doesn't exist, a zero width space is
    /// returned. note the builder does not contain the input generics as normally used by iced view() calls. this
    /// allows us to control which messages get generated without the need to pass them in from upstream, which is
    /// useful in this case since we already know what messages should correspond to the task Elements. as long as the
    /// caller contains a message with a TemplateTaskMessage parameter, the Element can be map()ed to the upstream
    /// message, and everything works as expected
    pub fn build_template<'a>(&'a self, entry_date: NaiveDate) -> Element<'a, TemplateTaskMessage> {
        let name = Text::new(self.name.clone());

        let expand_button_text = if self.expanded { "\\/" } else { "<" };

        let expand_button = button(Text::new(expand_button_text)).on_press(TemplateTaskMessage {
            date: entry_date,
            name: self.name.clone(),
            task_type: self.task_type,
            message: TemplateMessage::Common(CommonMessage::ExpandToggled),
        });

        if let Some(entry) = self.entries.get(&entry_date) {
            match entry {
                TaskDataFormat::Standard(standard_data) => {
                    let checkbox = checkbox("", standard_data.completed).on_toggle(move |ticked| {
                        TemplateTaskMessage::snapshot(
                            self,
                            entry_date,
                            TemplateMessage::Standard(StandardMessage::CheckedBox(ticked)),
                        )
                    });

                    let minimized_task = row![name, expand_button, checkbox];

                    let text =
                        widget::text_editor(&standard_data.text_content).on_action(move |action| {
                            TemplateTaskMessage::snapshot(
                                self,
                                entry_date,
                                TemplateMessage::Standard(StandardMessage::TextEdit(action)),
                            )
                        });

                    if !self.expanded {
                        minimized_task.into()
                    } else {
                        column![minimized_task, text].into()
                    }
                }
                TaskDataFormat::MultiBinary(multi_binary_data) => {
                    let minimized_task = row![name, expand_button];

                    let mut subtask_checkboxes = column![];

                    for (i, completion) in multi_binary_data.subtask_completion.iter().enumerate() {
                        let checkbox = checkbox("", *completion).on_toggle(move |ticked| {
                            TemplateTaskMessage::snapshot(
                                self,
                                entry_date,
                                TemplateMessage::MultiBinary(MultiBinaryMessage::CheckedNth((
                                    i, ticked,
                                ))),
                            )
                        });

                        let subtask_name = match &self.common_entry_format {
                            TaskCommonDataFormat::MultiBinary(multi_binary_common_data) => {
                                multi_binary_common_data.subtask_names[i].clone()
                            }
                            _ => unreachable!("malformed CommonDataFormat"),
                        };

                        let name_text = Text::new(subtask_name);

                        subtask_checkboxes = subtask_checkboxes.push(row![name_text, checkbox]);
                    }

                    let text = widget::text_editor(&multi_binary_data.text_content).on_action(
                        move |action| {
                            TemplateTaskMessage::snapshot(
                                self,
                                entry_date,
                                TemplateMessage::MultiBinary(MultiBinaryMessage::TextEdit(action)),
                            )
                        },
                    );

                    if !self.expanded {
                        minimized_task.into()
                    } else {
                        column![minimized_task, subtask_checkboxes, text].into()
                    }
                }
            }
        } else {
            Space::new(0, 0).into()
        }
    }

    /// update logic for TemplateTasks based on the given TemplateTaskMessage
    pub fn update(&mut self, task_message: TemplateTaskMessage) {
        if let Some(data_format) = self.get_entry_mut(task_message.date) {
            match (task_message.message, task_message.task_type, data_format) {
                (TemplateMessage::Common(common_message), _, _) => match common_message {
                    CommonMessage::ExpandToggled => {
                        self.expanded = !self.expanded;
                    }
                },
                (
                    TemplateMessage::Standard(standard_message),
                    TaskType::Standard,
                    TaskDataFormat::Standard(standard_data),
                ) => match standard_message {
                    StandardMessage::CheckedBox(checked) => {
                        standard_data.set_completion(checked);
                    }
                    StandardMessage::TextEdit(action) => {
                        standard_data.text_content.perform(action);
                    }
                },
                (
                    TemplateMessage::MultiBinary(multi_binary_message),
                    TaskType::MultiBinary,
                    TaskDataFormat::MultiBinary(multi_binary_data),
                ) => match multi_binary_message {
                    MultiBinaryMessage::CheckedNth((index, checked)) => {
                        multi_binary_data.set_completion(index, checked);
                    }
                    MultiBinaryMessage::TextEdit(action) => {
                        multi_binary_data.text_content.perform(action);
                    }
                },
                _ => {
                    unreachable!("malformed template task");
                }
            }
        }
    }
}

#[derive(Debug, Default)]
/// collection of all the loaded templates
pub struct TemplateTasks {
    template_store: Vec<TemplateTask>,
}

impl TemplateTasks {
    /// inserts a new template into the structure
    pub fn add_template(&mut self, new_template: TemplateTask) {
        self.template_store.push(new_template);
    }

    /// returns all templates in the template store
    pub fn get_all_templates(&self) -> &Vec<TemplateTask> {
        &self.template_store
    }

    /// returns a Vec of all the templates that are scheduled to be active on the given date
    pub fn get_active_templates(&self, active_date: NaiveDate) -> Vec<&TemplateTask> {
        self.template_store
            .iter()
            .filter(|task| task.is_active(active_date))
            .collect()
    }

    /// returns a Vec of mutable templates that are scheduled to be active on the given date
    pub fn get_active_templates_mut(&mut self, active_date: NaiveDate) -> Vec<&mut TemplateTask> {
        self.template_store
            .iter_mut()
            .filter(|task| task.is_active(active_date))
            .collect()
    }

    /// generate any missing entries for tasks scheduled on the given date
    pub fn generate_template_entries(&mut self, active_date: NaiveDate) {
        let active_templates = self.get_active_templates_mut(active_date);

        for template in active_templates {
            if template.get_entry(active_date).is_none() {
                template.add_empty_entry(template.task_type, active_date);
            }
        }
    }

    /// writes all templates to disk
    pub fn save_templates(&self) {
        for template in &self.template_store {
            let template_disk: TemplateTaskDisk = template.into();

            let task_filename = "task_".to_string()
                + &template_disk.name.clone()
                + &template_disk.task_type.to_string()
                + ".json";

            let mut task_path = template_tasks_path();
            task_path.push(task_filename);

            let template_json = serde_json::to_string_pretty(&template_disk)
                .expect("couldn't serialize template_disk");

            fs::write(task_path, template_json).expect("couldn't save template json");
        }
    }

    /// loads all templates from disk
    pub fn load_templates(&mut self) {
        let mut template_paths = Vec::new();

        if let Ok(files) = fs::read_dir(template_tasks_path()) {
            for file in files.flatten() {
                template_paths.push(file.path());
            }
        }

        for path in template_paths {
            if let Ok(template_string) = fs::read_to_string(path)
                && let Ok(template_disk) =
                    serde_json::from_str::<TemplateTaskDisk>(&template_string)
            {
                self.add_template((&template_disk).into());
            }
        }
    }

    /// update logic for TemplateTasks. locates the template based on the data contained in the TemplateTaskMessage,
    /// passing along the update to it. the template should always exist, since it was the one that created the message
    /// in the first place
    pub fn update(&mut self, template_message: TemplateTaskMessage) {
        if let Some(template) = self.template_store.iter_mut().find(|potential_task| {
            potential_task.name == template_message.name
                && potential_task.task_type == template_message.task_type
        }) {
            template.update(template_message);
        }
    }
}
